//! HPET driver implementation

use super::{PIT_IRQ, RTC_IRQ, Timer, TimerError};
use crate::{
    arch::x86_64::{
        apic::{
            self,
            ioapic::{self, allocate_irq_at, gsi_to_irq, irq_to_gsi, map_irq_to_vector},
        },
        cpu::get_cs,
        interrupts::{self, Dpl, GateType, IsrStub, Present},
    },
    mem::mmio::MmioArea,
    sync::spinlock::{SpinLock, SpinLockDropable},
};
use core::{mem::transmute, ptr, time::Duration};
use modular_bitfield::prelude::*;
use utils::{
    id_allocator::{Id, IdAllocator, IdAllocatorError},
    sanity_assert,
};

/// The different interrupt routing modes the HPET timer supports
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum InterruptRoutingMode {
    /// Each timer should be mapped to some IRQ on which it'll trigger interrupts.
    ///
    /// NOTE: You can't just map any IRQ, a bitmap of the available IRQs for this timer can be
    /// found on the timer's INT_ROUTE_CAP bits in the timer's configuration register
    Normal = 0,
    /// Timer 0 will trigger interrupts on IRQ0 instead of the PIC
    /// Timer 1 will trigger interrupts on IRQ8 instead of the RTC
    /// The rest of the timers interrupt mappings is the same as on `Normal` mode.
    ///
    /// NOTE: Using the PIC and RTC when this mode is enabled is impossible.
    Legacy = 1,
}

/// The delivery mode a specific timer will use
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum DeliveryMode {
    /// The timer will issue interrupts as specified by `InterruptRoutingMode`.
    ///
    /// The interrupt type will be determined by the `TriggerMode`
    Interrupt(IsrStub, TriggerMode),
    /// The timer will deliver a FSB message instead of issuing an interrupt
    ///
    /// NOTE: When using this delivery mode, only `EdgeTriggered` interrupts can be used.
    Fsb(FsbInterruptRoute),
}

/// Dictates whether the interrupt generated by the timer is level or edge triggered
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TriggerMode {
    /// Interrupts will be `EdgeTriggered`
    ///
    /// NOTE: This is not possible when FSB is enabled
    EdgeTriggered = 0b0,
    /// Interrupts will be `LevelTriggered`
    ///
    /// NOTE: From experimentation I've done on various machines, using `LevelTriggered` interrupts
    /// will not let you disable the recievings of interrupts.
    LevelTriggered = 0b1,
}

/// The different modes the timer can operate on
///
/// NOTE: Every implementation promises the timer supports `OneShot` mode, but only some
/// implementations allow for `Periodic`
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TimerMode {
    /// The timer will fire only once. In order for it to fire again, it should be reconfigured
    OneShot = 0b0,
    /// Once the timer is configured, it will fire periodically at the specified rate
    Periodic = 0b1,
}
/// A struct to pass in the other parameters for the timer.
///
/// See `trait Timer`
#[derive(Debug)]
pub struct AdditionalConfig {
    /// Making this be `false` will make the HPET not trigger interrupts on the configured IRQs.
    /// Other than that, operation is the exactly the same.
    pub recieve_interrupts: bool,
    /// The delivery mode to configure
    pub delivery_mode: DeliveryMode,
}

/// A ZST for the readable regs
struct ReadableRegs;

/// A ZST for the writeable regs
struct WriteableRegs;

/// The structure of the General Capabilities MMIO register
#[bitfield]
#[derive(Clone, Copy)]
#[repr(u64)]
struct GeneralCapabilities {
    rev_id: B8,
    num_tim_cap: B5,
    count_size_cap: B1,
    reserved: B1,
    leg_route_cap: B1,
    vendor_id: u16,
    counter_clock_period: u32,
}

/// The structure of the General Configurations MMIO register
#[bitfield]
#[derive(Clone, Copy)]
#[repr(u64)]
struct GeneralConfiguration {
    enable: B1,
    legacy_route: B1,
    reserved1: B62,
}

type GeneralInterruptStatusValue = u64;

type MainCounterValue = u64;

type TimerComparator = u64;

/// The structure of the Timer Configuration MMIO register
#[bitfield]
#[derive(Clone, Copy)]
#[repr(u64)]
struct TimerConfiguration {
    reserved0: B1,
    int_type: B1,
    int_enable: B1,
    timer_type: B1,
    periodic_int_capable: B1,
    size_capable: B1,
    value_set: B1,
    reserved1: B1,
    timer_32bit_mode: B1,
    int_route: B5,
    fsb_int_enable: B1,
    fsb_int_delivery: B1,
    reserved2: B16,
    int_route_cap: B32,
}

/// FSB interrupt routing
#[bitfield]
#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u64)]
struct FsbInterruptRoute {
    /// The value that should be written when an FSB message is recieved
    fsb_int_val: B32,
    /// The physical address in memory to which the specified value should be written to
    /// When the FSB message is recieved
    ///
    /// XXX: I think this is physical memory
    dsb_int_addr: B32,
}

// NOTE: I could make this a ZST, but I don't think it's worth the trouble
/// One of HPET's specific timer
pub struct HpetTimer {
    /// The HPET MMIO registers
    area: MmioArea<usize, usize, u64>,
    /// The ID assigned of this timer
    id: Id,
}

/// The HPET
pub struct Hpet {
    /// The HPET MMIO registers
    area: MmioArea<usize, usize, u64>,
    /// The main clock period of the HPET. This is cached for faster access
    main_clock_period: u64,
    /// The minimum ticks that any HPET timer can tick for. This is as well cached for faster
    /// access
    minimum_tick: u16,
    /// ID allocator for the timers
    timer_ids: IdAllocator,
    /// The `InterruptRoutingMode` the HPET was configured with. This is as well cached for faster
    /// access
    int_routing_mode: InterruptRoutingMode,
}

// TODO: Move this out of here
const NANO_TO_FEMTOSEC: u128 = 1_000_000;

/// The global static HPET instance
pub static HPET: SpinLock<Hpet> = SpinLock::new(Hpet {
    area: MmioArea::new(ptr::dangling_mut()),
    main_clock_period: 0,
    minimum_tick: 0,
    timer_ids: IdAllocator::uninit(),
    int_routing_mode: InterruptRoutingMode::Normal,
});

impl ReadableRegs {
    /// Offset to the HPET's `GeneralCapabilities` register
    const GENERAL_CAPABILITIES: usize = 0x0;
    /// Offset to the HPET's `GeneralConfiguration` register
    const GENERAL_CONFIGURATION: usize = 0x10;
    /// Offset to the HPET's `GeneralInterruptStatusValue` register
    const GENERAL_INTERRUPT_STATUS: usize = 0x20;
    /// Offset to the HPET's `MainCounterValue` register
    const MAIN_COUNTER_VALUE: usize = 0xf0;
}

impl WriteableRegs {
    /// Offset to the HPET's `GeneralConfiguration` register
    const GENERAL_CONFIGURATION: usize = 0x10;
    /// Offset to the HPET's `GeneralInterruptStatusValue` register
    const GENERAL_INTERRUPT_STATUS: usize = 0x20;
    /// Offset to the HPET's `MainCounterValue` register
    const MAIN_COUNTER_VALUE: usize = 0xf0;
}

impl Hpet {
    /// The maximum amount of timers supported by the HPET
    ///
    /// NOTE: This is not a guarantee, but a limit. The hardware might have less (usually it has 3)
    const MAX_TIMER_AMOUNT: usize = 32;

    /// Converts the time to cycles.
    ///
    /// IMPORTANT NODE: If the time is not a multiple of the main clock period, it will be rounded
    /// up to the next multiple of the main clock period.
    #[inline]
    pub const fn time_to_cycles(&self, time: Duration) -> u64 {
        let diff = (time.as_nanos() * NANO_TO_FEMTOSEC) % (self.main_clock_period as u128);

        (((time.as_nanos() * NANO_TO_FEMTOSEC) + diff) / (self.main_clock_period as u128)) as u64
    }

    // TODO: Move away from transmute?
    /// Set the HPETs interrupt routing mode
    ///
    /// SAFETY: This function is unsafe because calling it not during initialization can cause UB.
    #[inline]
    unsafe fn set_interrupt_routing(&mut self, int_routing_mode: InterruptRoutingMode) {
        // Make sure it's supported
        let capabilities: GeneralCapabilities =
            unsafe { transmute(self.area.read(ReadableRegs::GENERAL_CAPABILITIES)) };

        if int_routing_mode == InterruptRoutingMode::Legacy {
            assert!(
                capabilities.leg_route_cap() == true.into(),
                "HPET: Legacy routing not supported"
            );
        }

        // Set the interrupt routing mode
        let mut config: GeneralConfiguration =
            unsafe { transmute(self.area.read(ReadableRegs::GENERAL_CONFIGURATION)) };

        config.set_legacy_route(int_routing_mode as u8);
        unsafe {
            self.area
                .write(WriteableRegs::GENERAL_CONFIGURATION, config.into());
        };
    }

    /// Initialize the HPET
    ///
    /// SAFETY: This function is unsafe because it writes to MMIO registers, which can cause UB
    /// if the parameters passed are not valid.
    #[inline]
    pub unsafe fn init(base: *mut u64, minimum_tick: u16, int_routing_mode: InterruptRoutingMode) {
        let mut hpet = HPET.lock();

        *hpet = Hpet::new(base, minimum_tick, int_routing_mode);

        // Sanity disable the HPET before we do anything
        hpet.set_disabled(true);
        unsafe {
            // Set and configure the interrupt routing
            hpet.set_interrupt_routing(int_routing_mode);
            // Reset the main counter value to a known state
            hpet.area.write(WriteableRegs::MAIN_COUNTER_VALUE, 0);
        }

        // Enable the HPET
        hpet.set_disabled(false);
    }

    /// Helper function to create the new HPET instance
    fn new(base: *mut u64, minimum_tick: u16, int_routing_mode: InterruptRoutingMode) -> Self {
        let mut hpet = Self {
            area: MmioArea::new(base),
            main_clock_period: 0,
            minimum_tick,
            timer_ids: IdAllocator::uninit(),
            int_routing_mode,
        };

        let capabilities: GeneralCapabilities =
            unsafe { transmute(hpet.area.read(ReadableRegs::GENERAL_CAPABILITIES)) };

        // Revision of 0 isn't valid
        sanity_assert!(capabilities.rev_id() != 0);

        // Making sure 64 bit capable. We don't support 32 bit mode
        sanity_assert!(capabilities.count_size_cap() == 1);

        // Sanity checking to make sure the clock period makes sense
        sanity_assert!(capabilities.counter_clock_period() < 0x05F5_E100);
        // Get the main clock's period
        hpet.main_clock_period = capabilities.counter_clock_period().into();

        // Get the max index of the timer
        let max_timer_index = capabilities.num_tim_cap().into();

        // Sanity checking to make sure the timer amount makes sense
        sanity_assert!(max_timer_index < Self::MAX_TIMER_AMOUNT);

        // Construct the range
        hpet.timer_ids = IdAllocator::new(Id(0)..Id(max_timer_index));

        hpet
    }

    /// Enable/disable the HPET (halt the main counter, effectively disabling all the timers)
    #[inline]
    pub fn set_disabled(&mut self, state: bool) {
        let mut config: GeneralConfiguration =
            unsafe { transmute(self.area.read(ReadableRegs::GENERAL_CONFIGURATION)) };

        config.set_enable((!state).into());

        unsafe {
            self.area
                .write(WriteableRegs::GENERAL_CONFIGURATION, config.into());
        };
    }
}

impl HpetTimer {
    /// Configure and initialize the delivery mode of the timer
    fn config_delivery_mode(
        &mut self,
        config: &mut TimerConfiguration,
        delivery_mode: DeliveryMode,
    ) -> Result<(), TimerError> {
        match delivery_mode {
            DeliveryMode::Fsb(fsb_info) => {
                // Return an error if FSB isn't supported
                if config.fsb_int_delivery() != true.into() {
                    return Err(TimerError::InvalidTimerFlags);
                }

                config.set_fsb_int_enable(true.into());
                // FSB doesn't support `Level` triggered interrupts
                config.set_int_type(TriggerMode::EdgeTriggered as u8);

                unsafe {
                    self.area
                        .write(self.fsb_interrupt_route_reg_offset(), fsb_info.into())
                };
            }
            DeliveryMode::Interrupt(isr_stub, int_type) => {
                let int_routing_mode = {
                    let hpet = HPET.lock();
                    hpet.int_routing_mode
                };

                let irq = {
                    match int_routing_mode {
                        InterruptRoutingMode::Legacy if self.id == Id(0) => unsafe {
                            ioapic::allocate_irq_at(PIT_IRQ).map_err(|_| TimerError::IrqError)?;
                            PIT_IRQ
                        },
                        InterruptRoutingMode::Legacy if self.id == Id(1) => unsafe {
                            ioapic::allocate_irq_at(RTC_IRQ).map_err(|_| TimerError::IrqError)?;
                            RTC_IRQ
                        },
                        _ => unsafe {
                            let gsi_bitmap = config.int_route_cap();

                            // Try to find an ID that is both free and is marked as legal
                            let gsi = (0_u32..32_u32)
                                .into_iter()
                                .find(|&i| {
                                    gsi_bitmap & (1 << i) != 0 && allocate_irq_at(i as u8).is_ok()
                                })
                                .ok_or(TimerError::IrqError)?;

                            gsi_to_irq(gsi)
                        },
                    }
                };

                println!("this is the irq {irq}");

                unsafe {
                    // Make sure the interrupt is masked off before we do any fiddiling with the
                    // IO APIC and IDT
                    ioapic::set_disabled(irq, true).unwrap();

                    // Install the new ISR
                    let vector = interrupts::install_isr(
                        isr_stub,
                        get_cs(),
                        0,
                        GateType::Interrupt,
                        Dpl::Kernel,
                        Present::Present,
                    )
                    .map_err(|_| TimerError::IdtError)?;

                    // Tell the IO APIC to map `irq` to the given `vector`
                    // XXX: Change the flags here!
                    map_irq_to_vector(vector, irq).unwrap();

                    // Now we can unmask the IRQ in the IO APIC
                    //
                    // NOTE: No interrupt should be triggered yet, since the timer is still
                    // disabled internally.
                    ioapic::set_disabled(irq, false).unwrap();
                };

                // IMPORTANT! Having FSB enabled overrides interrupts
                config.set_fsb_int_enable(false.into());
                config.set_int_type(int_type as u8);
            }
        }

        Ok(())
    }

    /// Initialize the timer with the given `time `and `timer_mode`
    pub fn new() -> Result<Self, TimerError> {
        let mut hpet = HPET.lock();

        let base = hpet.area.base();
        let id = hpet
            .timer_ids
            .allocate()
            .map_err(|_| TimerError::NoTimerAvailable)?;

        // We don't need HPET anymore, so release the lock
        drop(hpet);

        // TODO: Remove this limitation someday by allocating IRQ lines on IOAPIC so we could
        // allocate other timers than just 0
        assert!(id.0 == 0, "HPET: Only timer 0 is supported currently");

        Ok(Self {
            area: MmioArea::new(base),
            id,
        })
    }

    /// Check if the timer has fired
    ///
    /// **NOTE:** This is only valid for timers where the interrupts are level triggered.
    /// For edge triggered interrupts, the status bit will always be set to `0` and so `false` will be
    /// returned.
    #[inline]
    pub fn get_status(&self) -> bool {
        unsafe {
            let read: GeneralInterruptStatusValue =
                self.area.read(ReadableRegs::GENERAL_INTERRUPT_STATUS) & (1 << self.id.0);

            // If the timer has fired, we write 1 to clear the status bit
            if read != 0 {
                self.area
                    .write(WriteableRegs::GENERAL_INTERRUPT_STATUS, read);

                return true;
            }

            false
        }
    }

    /// Read the main counter value
    #[inline]
    pub fn read_main_counter(&self) -> MainCounterValue {
        unsafe { self.area.read(ReadableRegs::MAIN_COUNTER_VALUE) }
    }

    /// Get the timer's `TimerConfiguration` register address
    #[inline]
    const fn config_reg_offset(&self) -> usize {
        0x100 + (0x20 * self.id.0)
    }

    /// Get the timer's `TimerComparator` register address
    #[inline]
    const fn comparator_reg_offset(&self) -> usize {
        0x108 + (0x20 * self.id.0)
    }

    /// Get the timer's `TimerFsbInterruptRoute` register address
    #[inline]
    const fn fsb_interrupt_route_reg_offset(&self) -> usize {
        0x110 + (0x20 * self.id.0)
    }

    /// Get the timer's ID
    #[inline]
    pub const fn id(&self) -> Id {
        self.id
    }
}

impl Timer for HpetTimer {
    type TimerMode = TimerMode;
    type AdditionalConfig = AdditionalConfig;

    fn configure(
        &mut self,
        time: Duration,
        timer_mode: TimerMode,
        additional_config: Self::AdditionalConfig,
    ) -> Result<u64, TimerError> {
        let hpet = HPET.lock();

        let mut config: TimerConfiguration =
            unsafe { transmute(self.area.read(self.config_reg_offset())) };

        // Make sure the timer is a 64bit one
        sanity_assert!(config.size_capable() == 1);

        // Make sure the timer mode is supported
        if timer_mode == TimerMode::Periodic && config.periodic_int_capable() == false.into() {
            return Err(TimerError::UnsupportedTimerMode);
        }

        let cycles_delta = hpet.time_to_cycles(time);
        // We want to tick for `time`. So we add the current main counter's value and write this
        // to the comparator
        let target_cycles =
            unsafe { hpet.area.read(ReadableRegs::MAIN_COUNTER_VALUE) + cycles_delta };

        // We don't need the HPET instance anymore
        drop(hpet);

        self.config_delivery_mode(&mut config, additional_config.delivery_mode)?;

        // Make sure we aren't operating in 32 bit mode
        config.set_timer_32bit_mode(false.into());
        config.set_timer_type(timer_mode as u8);
        config.set_int_enable(additional_config.recieve_interrupts.into());

        match timer_mode {
            TimerMode::Periodic => {
                // If we're operating in `Periodic` mode, we need to also enable the `set value` flag
                // to tell the HPET this write isn't an ordinary write (make it write to the
                // comparator) and then the second write will only modify the accumulator, so when
                // the interrupt is triggered the comparator is incremented by `cycles_delta` count

                config.set_value_set(1);
                unsafe {
                    self.area.write(self.config_reg_offset(), config.into());
                    self.area.write(self.comparator_reg_offset(), target_cycles);
                    self.area.write(self.comparator_reg_offset(), cycles_delta);
                };
            }
            TimerMode::OneShot => {
                // On `OneShot`, it's simply write "delta + main timer" and write the config as
                // usual
                unsafe {
                    self.area.write(self.config_reg_offset(), config.into());
                    self.area.write(self.comparator_reg_offset(), target_cycles);
                };
            }
        }

        Ok(target_cycles)
    }

    /// Disable this specific timer (it just masks off the interrupts, so it's effectively disabled)
    ///
    /// NOTE: In order for this timer to generate interrupts and work, you also need to make sure:
    ///     1. The HPET isn't disabled
    ///     2. Make sure interrupts aren't masked in the IF flag
    ///     3. Timer was configured with `recieve_interrupts == true`. (Otherwise it'll work just
    ///        fine just won't trigger interrupts)
    fn set_disabled(&mut self, state: bool) {
        let mut config: TimerConfiguration =
            unsafe { transmute(self.area.read(self.config_reg_offset())) };

        config.set_int_enable((!state).into());

        unsafe {
            self.area.write(self.config_reg_offset(), config.into());
        }
    }
}

impl SpinLockDropable for HpetTimer {
    fn custom_unlock(&mut self) {
        self.set_disabled(true);
    }
}

unsafe impl Send for Hpet {}
unsafe impl Sync for Hpet {}

unsafe impl Send for HpetTimer {}
unsafe impl Sync for HpetTimer {}

impl SpinLockDropable for Hpet {}
